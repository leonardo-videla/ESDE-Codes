function [newA, newseq, newx]=community_matrix(A, seq, x, step)newA=A;newx=x;N=size(A, 1);par1=-0.011;par2=-0.009;if (length(seq)==1 && step==0)  newA(3,1)=par1;  newA(3,2)=A(1,2);  newA(1,3)=par1;  newA(2,3)=A(2,1);  newA(3,3)=A(1,1);  newseq=[-1 0];  newx(1)=0.95*x(1);  newx(3)=0.05*x(1);   return;else   if(length(seq)==1 && step== 1)    newA(4,2)=par2;    newA(4,1)=A(2,1);    newA(2,4)=par2;    newA(1,4)=A(1,2);    newA(4,4)=A(2,2);    newseq=[-1 1];    newx(2)=0.95*x(2);    newx(4)=0.05*x(2);       return;  endifendifif (step==-1) %borrar entrada de la matriz  pos=code(seq);  newA(pos, :)=zeros (1, N);  newA(:, pos)=zeros(N, 1);   newseq=seq(1:length(seq)-1);  newx(pos)=0;else  % Si no, copiamos desde el ultimo ancestro conocido  newseq=[seq step];  n=length (seq);  m=1;  %Ubica ultimo ancestro conocido  candidates=zeros(1, n);  for i=2:n   if (seq(i)==step)      m=i;      candidates (i)=x(code(seq(1:i)));     endif  endfor     posnew=code(newseq)  if m==1    posmother=1+step  else     posmother=code(seq(1:choose_ancestor(seq, candidates)))  endif  %Copia  newA(posnew, :)=A(posmother, :);  newA(:, posnew)=A (:, posmother);  if (step==0)    par=par1;  else     par=par2;  endif  newA(posnew, posmother)=par;  newA(posmother, posnew)=par;  newA(posnew, posnew)=A(posmother, posmother);  newx(posnew)=0.05*x(posmother);  newx(posmother)=0.95*x(posmother);endifendfunction